{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./mock/src/build-posts.js","webpack:///./mock/src/parse.util.js","webpack:///external \"fs\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","parseMarkdown","require","fs","config","JSON","parse","readFileSync","process","argv","outputFile","posts","postsIn","callsRemaining","length","filePath","readFile","err","data","console","log","guid","assign","body","split","writeFile","concat","stringify","_loop","THEMATIC_BREAK_CHARS","SETEXT_CHARS","NODE_KIND","STRING","BOLD","BLANK","BLOCKQUOTE","BREAK","CODE_INLINE","CODE_FENCE","HEADING","IMAGE","ITALICS","LINK","LIST_ITEM","LIST_ORDERED","LIST_UNORDERED","PARAGRAPH","STRIKE","THEMATIC_BREAK","escapeRegExp","string","replace","hasSetext","line","has","which","setextChar","search","RegExp","hasThematicBreakFor","breakChar","getHeaderATX","matches","match","inline","level","getImageDef","url","alt","getLinkDef","title","getCodeFence","indentation","info","trim","getBlockquote","getListmarker","content","kind","symbol","w","start","unindent","currChar","slice","getLast","arr","insertSibling","nodes","sibling","currNode","found","left","right","newNodes","splitNode","undefined","end","push","parseSplit","delimNode","criteria","forEach","val","parseNodes","parseFn","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","next","done","node","return","parseInline","linkDefinitions","imageDefinitions","parseOrder","depth","parseTarget","pop","targetSymbol","targetKind","symbolStack","prevSymbol","pos","tempSymbol","parseGroup","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_loop3","imageDef","meta","src","_iterator2","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_loop4","linkDef","_iterator3","autoLinks","map","internalNodes","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_loop2","autoLink","internalNode","_iterator4","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","parseInner","innerNodes","children","parseBlock","block","isLoose","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","childBlock","lines","chunks","blockData","parseLines","defaultSymbol","blocks","prevBlock","codeFenceMeta","active","listMeta","blanks","containerBlocks","setextType","headerATX","blockquote","codeFence","listMarker","indentedLine","sep","createNewblock","innerLines","listItemBlock","listBlock","align","containerBlock","lineNumber","_i"],"mappings":"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","file":"build-posts.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","var parseMarkdown = require('./parse.util');\r\nvar fs = require('fs');\r\n\r\nvar config = JSON.parse(fs.readFileSync(process.argv[2], 'utf8'));\r\n\r\nlet outputFile = config.outputFile;\r\nlet posts = {};\r\n\r\nlet postsIn = config.posts;\r\nlet callsRemaining = postsIn.length;\r\nfor (let i = 0; i < postsIn.length; i++) {\r\n    let filePath = postsIn[i].filePath;\r\n    fs.readFile(filePath, 'utf8', function(err, data) {\r\n        callsRemaining -= 1;\r\n        if (err) {\r\n            return console.log(err);\r\n        }\r\n        posts[postsIn[i].guid] = Object.assign({\r\n            body: parseMarkdown(data.split('\\r\\n'))\r\n        }, postsIn[i]);\r\n        if (callsRemaining === 0) {\r\n            fs.writeFile(\r\n                outputFile, \r\n                `module.exports = ${JSON.stringify(posts)};`,\r\n                function(err) {\r\n                    if (err) {\r\n                        return console.log(err);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    });\r\n}\r\n","const THEMATIC_BREAK_CHARS = ['*', '-', '_'];\r\nconst SETEXT_CHARS = ['=', '-'];\r\nconst NODE_KIND = {\r\n    STRING: '',\r\n    BOLD: '**',\r\n    BLANK: 'blank',\r\n    BLOCKQUOTE: '>',\r\n    BREAK: 'br',\r\n    CODE_INLINE: '`',\r\n    CODE_FENCE: '```',\r\n    HEADING: [\r\n        '#',\r\n        '##',\r\n        '###',\r\n        '####',\r\n        '#####',\r\n        '#######',\r\n    ],\r\n    IMAGE: 'img',\r\n    ITALICS: '*',\r\n    LINK: '[]',\r\n    LIST_ITEM: 'li',\r\n    LIST_ORDERED: 'ol',\r\n    LIST_UNORDERED: 'ul',\r\n    PARAGRAPH: 'p',\r\n    STRIKE: '~',\r\n    THEMATIC_BREAK: 'hr'\r\n}\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\r\nfunction escapeRegExp(string) {\r\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\r\n}\r\n\r\nfunction hasSetext(line) {\r\n    let has = false;\r\n    let i = 0;\r\n    let which = 0;\r\n    while (i < SETEXT_CHARS.length && !has) {\r\n        let setextChar = SETEXT_CHARS[i];\r\n        has = line.search(new RegExp(`^[ ]{0,3}[${setextChar}]{3,}`)) >= 0;\r\n        which += 1;\r\n        i += 1;\r\n    }\r\n    return has ? which : 0;\r\n}\r\n\r\nfunction hasThematicBreakFor(line) {\r\n    let has = false;\r\n    let i = 0;\r\n    while (i < THEMATIC_BREAK_CHARS.length && !has) {\r\n        let breakChar = THEMATIC_BREAK_CHARS[i];\r\n        has = line.search(new RegExp(`^[ ]{0,3}([${breakChar}][ ]*){3,}$`)) >= 0;\r\n        i += 1;\r\n    }\r\n    return has;\r\n}\r\n\r\nfunction getHeaderATX(line) {\r\n    let matches = line.match(/^[ ]{0,3}[#]{1,6}[ ](.*)$/);\r\n    if (matches && matches.length > 1) {\r\n        return {\r\n            inline: matches[1],\r\n            level: line.match(/^[ ]{0,3}[#]{1,6}/g)[0].length\r\n        };\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getImageDef(line) {\r\n    let matches = line.match(/^[ ]{0,3}!\\[(.+)\\]:[ ]*([^ \\r\\n]+)[ ]*(.*)/);\r\n    if (matches && matches.length > 2) {\r\n        return {\r\n            key: matches[1],\r\n            url: matches[2],\r\n            alt: matches[3]\r\n        };\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getLinkDef(line) {\r\n    let matches = line.match(/^[ ]{0,3}\\[(.+)\\]:[ ]*([^ \\r\\n]+)[ ]*(.*)/);\r\n    if (matches && matches.length > 2) {\r\n        return {\r\n            key: matches[1],\r\n            url: matches[2],\r\n            title: matches[3]\r\n        };\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getCodeFence(line) {\r\n    let matches = line.match(/^([ ]{0,3})(`{3,})(.*)$/);\r\n    if (matches && matches.length > 2) {\r\n        return {\r\n            indentation: matches[1].length,\r\n            n: matches[2].length,\r\n            info: matches[3] ? matches[3].trim() : ''\r\n        };\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getBlockquote(line) {\r\n    let matches = line.match(/^[ ]{0,3}>[ ]{0,1}(.*)$/);\r\n    if (matches) {\r\n        return matches.length > 0 ? matches[1] : '';\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getListmarker(line) {\r\n    let matches = line.match(/^([ ]*)([-+*])([ ]{1,4})(.*)$/);\r\n    if (matches && matches.length > 4) {\r\n        let content = matches[4];\r\n        if (content && content !== '') {\r\n            return {\r\n                kind: NODE_KIND.LIST_UNORDERED,\r\n                symbol: matches[2],\r\n                indentation: matches[1].length,\r\n                w: 1,\r\n                n: matches[3].length,\r\n                inline: content\r\n            }\r\n        }\r\n    }\r\n\r\n    matches = line.match(/^^([ ]*)([0-9]{1,9})([.)])([ ]{1,4})(.*)$/);\r\n    if (matches && matches.length > 5) {\r\n        let content = matches[5];\r\n        if (content && content !== '') {\r\n            return {\r\n                kind: NODE_KIND.LIST_ORDERED,\r\n                symbol: matches[3],\r\n                indentation: matches[1].length,\r\n                w: matches[2].length,\r\n                n: matches[4].length,\r\n                start: matches[2],\r\n                inline: content\r\n            }\r\n        }\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nfunction unindent(line, indentation) {\r\n    if (!line || !line.length) {\r\n        return line;\r\n    }\r\n    let i = 0, currChar = ' ';\r\n    while (i < line.length && i <= indentation && currChar === ' ') {\r\n        currChar = line[i];\r\n        i += 1;\r\n    }\r\n    return line.slice(i - 1);\r\n}\r\n\r\nfunction getLast(arr) {\r\n    if (arr && arr.length > 0) {\r\n        return arr[arr.length - 1];\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction insertSibling(nodes, sibling) {\r\n    let i = 0;\r\n    let currNode = nodes[i];\r\n    let found = false;\r\n    let left = '';\r\n    let right = '';\r\n    let newNodes = [];\r\n    let splitNode = undefined;\r\n    while (i < nodes.length && !found) {\r\n        if (sibling.start >= currNode.start && sibling.end <= currNode.end) {\r\n            found = true;\r\n            left = currNode.content.slice(0, sibling.start - currNode.start);\r\n            right = currNode.content.slice(currNode.content.length + sibling.end - currNode.end);\r\n            splitNode = currNode;\r\n        } else {\r\n            newNodes.push(currNode);\r\n        }\r\n        i += 1;\r\n        currNode = nodes[i];\r\n    }\r\n    if (found) {\r\n        if (left !== '') {\r\n            newNodes.push({\r\n                kind: NODE_KIND.STRING,\r\n                start: splitNode.start,\r\n                end: sibling.start - 1,\r\n                content: left\r\n            });\r\n        }\r\n        newNodes.push(sibling);\r\n        if (right !== '') {\r\n            newNodes.push({\r\n                kind: NODE_KIND.STRING,\r\n                start: sibling.end + 1,\r\n                end: splitNode.end,\r\n                content: right\r\n            });\r\n        }\r\n    }\r\n    return newNodes;\r\n}\r\n\r\nfunction parseSplit(line, delimNode, criteria) {\r\n    let nodes = [];\r\n    line.split(criteria).forEach((val, i, arr) => {\r\n        if (val !== '') {\r\n            nodes.push({\r\n                kind: NODE_KIND.STRING,\r\n                content: val\r\n            });\r\n        }\r\n        if (i !== arr.length - 1) {\r\n            nodes.push(delimNode);\r\n        }\r\n    })\r\n    if (nodes.length === 0) {\r\n        nodes.push({\r\n            kind: NODE_KIND.STRING,\r\n            content: line\r\n        })\r\n    }\r\n    return nodes;\r\n}\r\n\r\nfunction parseGroup(line, targetSymbol, targetKind, depth) {\r\n    let symbolStack = [];\r\n    let nodes = [{\r\n        kind: NODE_KIND.STRING,\r\n        start: 0,\r\n        end: line.length - 1,\r\n        content: line\r\n    }];\r\n    for (let i = 0; i < line.length; i += 1) {\r\n        let symbol = line[i];\r\n        let prevSymbol = undefined;\r\n        if (symbolStack.length > 0) {\r\n            prevSymbol = symbolStack.pop();\r\n        }\r\n        if (symbol === targetSymbol) {\r\n            if (!prevSymbol || prevSymbol.val !== symbol || prevSymbol.pos + 1 === i) {\r\n                symbolStack.push(prevSymbol);\r\n                symbolStack.push({\r\n                    val: symbol,\r\n                    pos: i\r\n                });\r\n            } else {\r\n                let level = 0;\r\n                let tempSymbol = prevSymbol;\r\n                while (symbolStack.length > 0 && level < depth && tempSymbol.val === line[i + level]) {\r\n                    prevSymbol = tempSymbol;\r\n                    tempSymbol = symbolStack.pop();\r\n                    level += 1;\r\n                }\r\n                let start = prevSymbol.pos;\r\n                let end = i + level - 1;\r\n                let sibling = {\r\n                    kind: targetKind,\r\n                    start: start,\r\n                    end: end,\r\n                    content: line.slice(start + 1, end)\r\n                };\r\n                nodes = insertSibling(nodes, sibling);\r\n            }\r\n        } else if (prevSymbol) {\r\n            symbolStack.push(prevSymbol);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nfunction parseNodes(nodes, parseFn) {\r\n    let newNodes = [];\r\n    for (let node of nodes) {\r\n        if (node.kind === NODE_KIND.STRING) {\r\n            newNodes = newNodes.concat(parseFn(node));\r\n        } else {\r\n            newNodes.push(node);\r\n        }\r\n    }\r\n    return newNodes;\r\n}\r\n\r\nfunction parseInline(line, linkDefinitions, imageDefinitions) {\r\n    line = line ? line : '';\r\n    // parse the content here\r\n    let nodes = [{\r\n        kind: NODE_KIND.STRING,\r\n        start: 0,\r\n        end: line.length - 1,\r\n        content: line\r\n    }];\r\n\r\n    // Parse recursive blocks\r\n    let parseOrder = [\r\n        {\r\n            kind: NODE_KIND.ITALICS,\r\n            symbol: '*',\r\n            depth: 3\r\n        },\r\n        {\r\n            kind: NODE_KIND.STRIKE,\r\n            symbol: '~',\r\n            depth: 1\r\n        },\r\n        {\r\n            kind: NODE_KIND.CODE_INLINE,\r\n            symbol: '`',\r\n            depth: 1\r\n        }\r\n    ];\r\n    while (parseOrder.length > 0) {\r\n        let parseTarget = parseOrder.pop();\r\n        nodes = parseNodes(nodes, (node) => parseGroup(node.content, parseTarget.symbol, parseTarget.kind, parseTarget.depth));\r\n    }\r\n\r\n    // parse image definitions\r\n    for (let imageDef of imageDefinitions) {\r\n        nodes = parseNodes(nodes, (node) => {\r\n            return parseSplit(\r\n                node.content,\r\n                {\r\n                    kind: NODE_KIND.IMAGE,\r\n                    meta: {\r\n                        src: imageDef.url,\r\n                        alt: imageDef.alt\r\n                    }\r\n                },\r\n                new RegExp(`!\\\\[${escapeRegExp(imageDef.key)}\\\\]`)\r\n            );\r\n        });\r\n    }\r\n\r\n    // parse link definitions\r\n    for (let linkDef of linkDefinitions) {\r\n        nodes = parseNodes(nodes, (node) => {\r\n            return parseSplit(\r\n                node.content,\r\n                {\r\n                    kind: NODE_KIND.LINK,\r\n                    content: linkDef.key,\r\n                    meta: {\r\n                        url: linkDef.url,\r\n                        title: linkDef.title\r\n                    }\r\n                },\r\n                new RegExp(`\\\\[${escapeRegExp(linkDef.key)}\\\\]`)\r\n            );\r\n        });\r\n    }\r\n\r\n    // parse auto links\r\n    nodes = parseNodes(nodes, (node) => {\r\n        let autoLinks = node.content.match(/<[\\w+\\-.]{2,32}:.*?>/g);\r\n        if (!autoLinks) {\r\n            autoLinks = [];\r\n        } else {\r\n            autoLinks = autoLinks.map((val) => val.slice(1,-1));\r\n        }\r\n        let internalNodes = [node];\r\n        for (let autoLink of autoLinks) {\r\n            internalNodes = parseNodes(internalNodes, (internalNode) => {\r\n                return parseSplit(\r\n                    internalNode.content,\r\n                    {\r\n                        kind: NODE_KIND.LINK,\r\n                        content: autoLink,\r\n                        meta: {\r\n                            url: autoLink\r\n                        }\r\n                    },\r\n                    new RegExp(`\\\\<${escapeRegExp(autoLink)}\\\\>`)\r\n                );\r\n            });\r\n        }\r\n        return internalNodes;\r\n    });\r\n\r\n    // parse line breaks\r\n    nodes = parseNodes(nodes, (node) => {\r\n        return parseSplit(\r\n            node.content,\r\n            {\r\n                kind: NODE_KIND.BREAK\r\n            },\r\n            '\\\\\\n'\r\n        );\r\n    });\r\n\r\n    for (let node of nodes) {\r\n        node.start = undefined;\r\n        node.end = undefined;\r\n        let parseInner = false;\r\n        if (node.kind === NODE_KIND.ITALICS) {\r\n            if (node.content.length > 1 && node.content[0] === '*' && node.content[node.content.length - 1] === '*') {\r\n                node.kind = NODE_KIND.BOLD;\r\n                node.content = node.content.slice(1, -1);\r\n            }\r\n            parseInner = true;\r\n        } else if (node.kind === NODE_KIND.STRIKE) {\r\n            parseInner = true\r\n        }\r\n\r\n        if (parseInner) {\r\n            let innerNodes = parseInline(node.content, linkDefinitions, imageDefinitions);\r\n            if (innerNodes.length > 1 || innerNodes[0].kind !== NODE_KIND.STRING) {\r\n                node.children = innerNodes;\r\n                node.content = undefined;\r\n            }\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nfunction parseBlock(block, linkDefinitions, imageDefinitions) {\r\n    let currNode = {\r\n        kind: block.kind,\r\n        meta: block.meta\r\n    };\r\n    if (block.children) {\r\n        currNode.children = [];\r\n\r\n        // Check looseness\r\n        let isLoose = false;\r\n        if (block.kind === NODE_KIND.LIST_ITEM) {\r\n            for (let childBlock of block.children) {\r\n                if (childBlock.kind === NODE_KIND.BLANK) {\r\n                    isLoose = true;\r\n                }\r\n            }\r\n        }\r\n        for (let childBlock of block.children) {\r\n            if (childBlock.kind !== NODE_KIND.BLANK) {\r\n                if (isLoose && childBlock.kind == NODE_KIND.STRING) {\r\n                    childBlock.kind = NODE_KIND.PARAGRAPH;\r\n                }\r\n                currNode.children.push(parseBlock(childBlock, linkDefinitions, imageDefinitions));\r\n            }\r\n        }\r\n    } else {\r\n        let nodes = parseInline(block.inline, linkDefinitions, imageDefinitions);\r\n        if (nodes.length === 1 && nodes[0].kind === NODE_KIND.STRING) {\r\n            currNode.content = nodes[0].content;\r\n        } else {\r\n            currNode.children = nodes;\r\n        }\r\n    }\r\n    return currNode;\r\n}\r\n\r\nfunction parseLines(lines, defaultSymbol) {\r\n    let blocks = [];\r\n    let prevBlock = undefined;\r\n    let linkDefinitions = [];\r\n    let imageDefinitions = [];\r\n    let codeFenceMeta = {\r\n        active: false,\r\n        indentation: 0,\r\n        n: 0,\r\n        block: {}\r\n    };\r\n    let listMeta = {\r\n        active: false,\r\n        symbol: undefined,\r\n        block: {},\r\n        blanks: 0\r\n    }\r\n    let containerBlocks = [];\r\n\r\n    for (let i = 0; i < lines.length; i++) {\r\n        let line = lines[i];\r\n\r\n        // parse leaf blocks \r\n        let setextType = hasSetext(line);\r\n        let headerATX = getHeaderATX(line);\r\n        let linkDef = getLinkDef(line);\r\n        let imageDef = getImageDef(line);\r\n        let blockquote = getBlockquote(line);\r\n        let codeFence = getCodeFence(line);\r\n        let listMarker = getListmarker(line);\r\n\r\n        if (codeFenceMeta.active) {\r\n            if (codeFence && codeFence.n >= codeFenceMeta.n) {\r\n                codeFenceMeta.active = false;\r\n                codeFenceMeta.n = 0;\r\n            } else {\r\n                let indentedLine = unindent(line, codeFenceMeta.indentation);\r\n                let sep = codeFenceMeta.block.inline === '' ? '' : '\\n';\r\n                codeFenceMeta.block.inline += `${sep}${indentedLine}`;\r\n            }\r\n        }  else if (listMarker) {\r\n            let createNewblock = false;\r\n            if (listMeta.active) {\r\n                listMeta.blanks = 0;\r\n                if (listMeta.block.indentation < listMarker.indentation) {\r\n                    let lastItemBlock = getLast(listMeta.block.children);\r\n                    lastItemBlock.innerLines.push(unindent(line, listMeta.block.indentation));\r\n                } else if (listMeta.symbol === listMarker.symbol) {\r\n                    let listItemBlock = {\r\n                        kind: NODE_KIND.LIST_ITEM,\r\n                        innerLines: [listMarker.inline]\r\n                    };\r\n                    listMeta.block.children.push(listItemBlock);\r\n                    containerBlocks.push(listItemBlock);\r\n                } else {\r\n                    createNewblock = true;\r\n                }\r\n            } else {\r\n                createNewblock = true;\r\n            }\r\n\r\n            if (createNewblock) {\r\n                let listItemBlock = {\r\n                    kind: NODE_KIND.LIST_ITEM,\r\n                    innerLines: [listMarker.inline]\r\n                };\r\n                let listBlock = {\r\n                    kind: listMarker.kind,\r\n                    w: listMarker.w,\r\n                    n: listMarker.n,\r\n                    align: listMarker.w + listMarker.n,\r\n                    indentation: listMarker.indentation,\r\n                    children: [listItemBlock]\r\n                };\r\n                if (listMarker.kind === NODE_KIND.LIST_ORDERED) {\r\n                    listBlock.meta = {\r\n                        start: listMarker.start\r\n                    };\r\n                }\r\n                listMeta.symbol = listMarker.symbol;\r\n                listMeta.active = true;\r\n                listMeta.blanks = 0;\r\n                listMeta.block = listBlock;\r\n                blocks.push(listBlock);\r\n                containerBlocks.push(listItemBlock);\r\n            }\r\n        } else if (line.trim() === '') {\r\n            if (listMeta.active) {\r\n                listMeta.blanks += 1;\r\n                if (listMeta.blanks < 2) {\r\n                    let lastItemBlock = getLast(listMeta.block.children);\r\n                    lastItemBlock.innerLines.push('');\r\n                } else {\r\n                    listMeta.active = false;\r\n                    listMeta.blanks = 0;\r\n                    blocks.push({\r\n                        kind: NODE_KIND.BLANK\r\n                    });\r\n                }\r\n            } else {\r\n                blocks.push({\r\n                    kind: NODE_KIND.BLANK\r\n                });\r\n            }\r\n        } else if (listMeta.active) {\r\n            listMeta.blanks = 0;\r\n            let lastItemBlock = getLast(listMeta.block.children);\r\n            lastItemBlock.innerLines.push(unindent(line, listMeta.block.indentation));\r\n        } else if (setextType) {\r\n            prevBlock.kind = NODE_KIND.HEADING[setextType - 1];\r\n        } else if (hasThematicBreakFor(line)) {\r\n            blocks.push({\r\n                kind: NODE_KIND.THEMATIC_BREAK\r\n            });\r\n        } else if (headerATX) {\r\n            blocks.push({\r\n                kind: NODE_KIND.HEADING[headerATX.level - 1],\r\n                inline: headerATX.inline\r\n            });\r\n        } else if (linkDef && (!prevBlock || prevBlock.kind === NODE_KIND.BLANK)) {\r\n            linkDefinitions.push(linkDef);\r\n        } else if (imageDef && (!prevBlock || prevBlock.kind === NODE_KIND.BLANK)) {\r\n            imageDefinitions.push(imageDef);\r\n        } else if (blockquote || blockquote === '') {\r\n            if (prevBlock && prevBlock.kind === NODE_KIND.BLOCKQUOTE) {\r\n                prevBlock.innerLines.push(blockquote);\r\n            } else {\r\n                let containerBlock = {\r\n                    kind: NODE_KIND.BLOCKQUOTE,\r\n                    innerLines: [blockquote]\r\n                };\r\n                blocks.push(containerBlock);\r\n                containerBlocks.push(containerBlock);\r\n            }\r\n        } else if (codeFence) {\r\n            codeFenceMeta.block = {\r\n                kind: NODE_KIND.CODE_FENCE,\r\n                inline: '',\r\n                meta: {\r\n                    info: codeFence.info\r\n                }\r\n            };\r\n            codeFenceMeta.active = true;\r\n            codeFenceMeta.indentation = codeFence.indentation;\r\n            codeFenceMeta.n = codeFence.n;\r\n            blocks.push(codeFenceMeta.block);\r\n        } else {\r\n            if (prevBlock && prevBlock.kind === defaultSymbol) {\r\n                prevBlock.inline = `${prevBlock.inline}\\n${line}`;\r\n            } else {\r\n                blocks.push({\r\n                    kind: defaultSymbol,\r\n                    inline: line\r\n                })\r\n            }\r\n        }\r\n\r\n        // remember context\r\n        if (blocks.length > 0) {\r\n            prevBlock = getLast(blocks);\r\n            prevBlock.lineNumber = i;\r\n        }\r\n    }\r\n\r\n    for (let containerBlock of containerBlocks) {\r\n        let blockData = parseLines(containerBlock.innerLines, NODE_KIND.STRING);\r\n        linkDefinitions.concat(blockData.linkDefinitions);\r\n        imageDefinitions.concat(blockData.imageDefinitions);\r\n        containerBlock.children = blockData.blocks;\r\n    }\r\n    return {\r\n        blocks: blocks,\r\n        linkDefinitions: linkDefinitions,\r\n        imageDefinitions: imageDefinitions\r\n    };\r\n}\r\n\r\nlet parseMarkdown = function(lines) {\r\n    let chunks = [];\r\n    let blockData = parseLines(lines, NODE_KIND.PARAGRAPH);\r\n    for (let i = 0; i < blockData.blocks.length; i++) {\r\n        if (blockData.blocks[i].kind !== NODE_KIND.BLANK) {\r\n            chunks.push(parseBlock(blockData.blocks[i], blockData.linkDefinitions, blockData.imageDefinitions));\r\n        }\r\n    }\r\n    return chunks;\r\n}\r\n\r\nmodule.exports = parseMarkdown;","module.exports = require(\"fs\");"],"sourceRoot":""}